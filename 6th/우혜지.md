# 부록A. 추상화 기법

<br>

## 추상화 기법

- **추상화** : 도메인의 복잡성을 단순화하고 직관적인 멘탈 모델을 만드는 데 사용할 수 있는 가장 기본적인 인지 수단

**[추상화 기법]**

- **분류와 인스턴스화**
    - 분류 : 객체의 구체적인 세부 사항을 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정
    - 인스턴스화 : 분류의 역으로, 범주로부터 객체를 생성
- **일반화와 특수화**
    - 일반화 : 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성 강조
    - 특수화 : 일반화의 역
- **집합과 분해**
    - 집합 : 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전체를 형성하는 과정
    - 분해 : 집합의 반대 과정. 전체를 부분으로 분리

<br>

## 분류와 인스턴스화

### 개념과 범주

- 객체를 분류하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 개념을 적용하는 것을 의미한다.
- **개념**이란 속성과 행위가 유사한 객체에 공통적으로 적용되는 관념이나 아이디어다.
- 객체들을 공통적인 특성을 기반으로 범주로 묶고 개념을 적용하는 것은 **범주**라는 정신적인 렌즈를 통해 세상을 바라보는 것과 유사하다.
- 세상에 존재하는 객체에 개념을 적용하는 과정을 **분류**라고 한다.
- 분류의 역은 타입에 해당하는 객체를 생성하는 과정으로 **인스턴스화** 또는 **예시**라고 한다.

### 타입

- 객체지향의 세계에서의 개념
- ‘수많은 개별적인 현상들’을 **객체**라고 하고, ‘하나의 개념’을 **타입**이라고 한다.
- 객체를 타입에 따라 분류하기 위해서는 객체가 타입에 속하는지 여부를 확인할 수 있어야 한다.
- 타입을 객체의 분류 장치로서 적용할 수 있으려면 다음과 같은 세 가지 관점에서의 정의가 필요하다.
    - 심볼 : 타입을 가리키는 간략한 이름이나 명칭
    - 내연 : 타입의 완전한 정의. 내연의 의미를 이용해 객체가 타입에 속하는지 여부를 확인할 수 있다.
    - 외연 : 타입에 속하는 모든 객체들의 집합

### 외연과 집합

- **단일 분류(single classification)** : 한 객체가 한 시점에 하나의 타입에만 속하는 것
- **다중 분류(multiple classification)** : 한 객체가 한 시점에 여러 타입에 속할 경우
- 대부분의 객체지향 프로그래밍 언어들은 단일 분류만을 지원한다.
- 한 객체는 오직 한 클래스의 인스턴스여야만 하며 동시에 두 개의 클래스의 인스턴스일 수는 없다.
- **동적 분류(dynamic classification)** : 객체가 한 집합에서 다른 집합의 원소로 자신이 속하는 타입을 변경할 수 있는 경우
- **정적 분류(static classification)** : 객체가 자신의 타입을 변경할 수 없는 경우
- 다중 분류와 동적 분류는 서로 배타적인 개념이 아니다.
개념적인 관점에서 다중 분류와 동적 분류를 함께 적용하는 것이 실세계의 복잡성을 모델링하는 데 유용하다.
- 우리가 사용하는 대부분의 언어는 정적 분류만 허용하며 동적 분류를 구현할 수 있는 방법을 제공하지 않는다.

### 클래스

- 객체지향 프로그래밍 언어를 이용해 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다.
- 만약 객체들이 동일한 특성을 가진다면 그것들은 동일한 카테고리에 속한다.
따라서 객체들의 카테고리는 객체들이 공유하는 공통적인 특성에 의해 정의된다.
- 클래스는 객체가 공유하는 본질적인 속성을 정의한다.

<br>

## 일반화와 특수화

### 범주의 계층

- 계층의 상위에 위치한 범주를 계층의 하위에 위치한 범주의 **일반화**라고 하고, 
계층의 하위에 위치한 범주는 계층의 상위에 위치한 범주의 **특수화**라고 한다.

### 서브타입

> **서브타입은 슈퍼타입이 가진 본질적인 속성과 함께 자신만의 추가적인 속성을 가진다.**
> 
- **슈퍼타입(supertype)** :  어떤 타입이 다른 타입보다 일반적인 경우
- **서브타입(subtype)** : 어떤 타입이 다른 타입보다 특수한 경우
- 슈퍼타입은 서브타입의 일반화이고 서브타입은 슈퍼타입의 특수화이다.
- 서브타입은 슈퍼타입의 본질적인 속성을 모두 포함하기 때문에 계층에 속하는 모든 서브타입들이 슈퍼타입의 속성을 공유한다.
    - 내연의 관점 : 슈퍼타입의 정의가 서브타입의 정의보다 더 일반적이다.
    - 외연의 관점 : 서브타입은 슈퍼타입의 부분집합으로 표현된다.
- 크레이그 라만은 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 다음과 같은 규칙을 준수해야 한다고 말한다.
    - **100% 규칙**
    타입의 내연과 관련된 규칙. 슈퍼타입의 정의가 100% 서브타입에 적용돼야만 한다.
    서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치해야 한다.
    - **Is-a 규칙**
    타입의 외연과 관련된 규칙. 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다.
    이는 대개 영어로 서브타입은 슈퍼타입이다(subtype is a supertype)라는 구문을 만듦으로써 테스트할 수 있다.

### 상속

- 프로그래밍 언어를 이용해 일반화와 특수화 관계를 구현하는 가장 일반적인 방법은 클래스 간의 상속을 사용하는 것이다.
- 일반화의 원칙은 한 타입이 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 순응(comformance)해야 한다는 것이다.
- 순응에는 구조적인 순응과 행위적인 순응의 두 가지 종류가 있다.
    - **구조적인 순응(structural conformance)**
    타입의 내연과 관련된 100% 규칙을 의미한다.
    서브타입은 슈퍼타입이 가지고 있는 속성과 연관관계 면에서 100% 일치해야 한다.
    ex. Person이 `name`이라는 속성을 가진다면 Person의 서브타입인 Employee 역시 `name`이라는 속성을 가질 것이다.
    - **행위적인 순응(behavioral conformance)**
    타입의 행위에 관한 것이며, 서브타입은 슈퍼타입을 행위적으로 대체 가능해야 한다.
    ex. Person이 `getAge()`라는 메시지에 대한 응답으로 나이를 반환한다면 서브타입인 Employee 역시 `getAge()`라는 메시지에 대한 응답으로 나이를 반환해야 한다.
- 상속의 또 다른 용도는 **코드 중복을 방지하고 공통 코드를 재사용하기 위한 언어적 메커니즘을 제공**하는 것이다.
- 만약 한 클래스가 다른 클래스를 상속한다면 **상속하는 타입은 부모 클래스의 데이터와 메서드를 사용하고, 수정하고, 확장할 수 있다**.
- 상속은 서브타이핑과 서브클래싱의 두 가지 용도로 사용될 수 있다.
    - 서브타이핑(subtyping) : 서브클래스가 슈퍼클래스를 대체할 수 있는 경우 ⇒ 인터페이스 상속
    - 서브클래싱(subclassing) : 서브클래스가 슈퍼클래스를 대체할 수 없는 경우 ⇒ 구현 상속
- 여러 클래스로 구성된 상속 계층에서 수신된 메시지를 이해하는 기본적인 방법은 클래스 간의 **위임(delegation)**을 사용하는 것이다.
    - 어떤 객체의 클래스가 수신된 메시지를 이해할 수 없다면 메시지를 클래스의 부모 클래스로 위임한다.
    - 만약 부모 클래스에서도 메시지를 이해할 수 없다면 자신의 부모 클래스로 다시 메시지를 위임한다.
    - 클래스 간의 위임 사슬은 계층 내의 어떤 클래스가 메시지를 처리하거나 최상위 부모 클래스에 위임할 때까지 계속된다.

<br>

## 집합과 분해

### 계층적인 복잡성

- 복잡성은 ‘계층’의 형태를 띤다.
- 단순한 형태로부터 복잡한 형태로 진화하는 데 걸리는 시간은 그 사이에 존재하는 ‘안정적인 형태’의 수와 분포에 의존한다.
- 안정적인 형태의 부분으로부터 전체를 구축하는 행위를 **집합**이라고 하고 
집합과 반대로 전체를 부분으로 분할하는 행위를 **분해**라고 한다.
- 집합은 전체의 내부로 불필요한 세부 사항을 감춰주기 때문에 추상화 메커니즘인 동시에 캡슐화 메커니즘이다.

### 합성 관계

- 객체와 객체 사이의 전체-부분 관계를 구현하기 위해서는 **합성 관계**를 사용한다.
- 합성 관계는 부분을 전체 안에 캡슐화함으로써 인지 과부하를 방지한다.
- 전체와 부분 간의 관계를 나타내는 합성 관계가 존재하는가 하면, 단순한 물리적 통로만이 존재하는 관계는 **연관 관계**라고 한다.
- 합성 관계로 연결된 객체는 포함하는 객체가 제거될 때 내부에 포함된 객체도 함께 제거된다.
- 연관 관계로 연결된 두 객체는 생명주기와 관련된 어떤 제약도 부과하지 않는다.
연관 관계로 연결된 두 객체는 독립적으로 제거될 수 있다.

### 패키지

- 합성 관계를 이용해 커다란 객체 그룹을 단순화하더라도 클래스의 수가 많아지면 얽히고 설킨 클래스 간의 의존성을 관리하는 일은 어렵다.
- 소프트웨어는 물리적인 형체라는 것이 존재하지 않으므로 구조를 단순화하기 위해서는 **서로 관련성이 높은 클래스 집합을 논리적인 단위로 통합**해야 한다.
- 소프트웨어의 전체적인 구조를 표현하기 위해 관련된 클래스 집합을 **하나의 논리적인 단위로 묶는 구성 요소**를 **패키지(package)** 또는 **모듈**(**module**)이라고 한다.
- 패키지를 이용하면 시스템의 전체적인 구조를 이해하기 위해 한 번에 고려해야 하는 요소의 수를 줄일 수 있다.
- 또한 개별 클래스가 아닌 클래스의 집합을 캡슐화함으로써 전체적인 복잡도를 낮출 수 있다.
- 합성 관계가 내부에 포함된 객체들의 존재를 감춤으로써 내부 구조를 추상화하는 것처럼 패키지는 내부에 포함된 클래스들을 감춤으로써 시스템의 구조를 추상화한다.
